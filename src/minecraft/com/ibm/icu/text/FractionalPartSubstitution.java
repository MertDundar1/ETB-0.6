package com.ibm.icu.text;

import java.text.ParsePosition;














































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































class FractionalPartSubstitution
  extends NFSubstitution
{
  private boolean byDigits = false;
  




  private boolean useSpaces = true;
  

















  FractionalPartSubstitution(int pos, NFRuleSet ruleSet, RuleBasedNumberFormat formatter, String description)
  {
    super(pos, ruleSet, formatter, description);
    


    if ((description.equals(">>")) || (description.equals(">>>")) || (ruleSet == this.ruleSet)) {
      byDigits = true;
      if (description.equals(">>>")) {
        useSpaces = false;
      }
    } else {
      this.ruleSet.makeIntoFractionRuleSet();
    }
  }
  















  public void doSubstitution(double number, StringBuffer toInsertInto, int position)
  {
    if (!byDigits) {
      super.doSubstitution(number, toInsertInto, position);





    }
    else
    {





      DigitList dl = new DigitList();
      dl.set(number, 20, true);
      




















      boolean pad = false;
      for (; count > Math.max(0, decimalAt); 
          




          ruleSet.format(digits[(--9997count)] - 48, toInsertInto, position + pos)) {
        if ((pad) && (useSpaces)) {
          toInsertInto.insert(position + pos, ' ');
        } else {
          pad = true;
        }
      }
      
      while (decimalAt < 0) {
        if ((pad) && (useSpaces)) {
          toInsertInto.insert(position + pos, ' ');
        } else {
          pad = true;
        }
        ruleSet.format(0L, toInsertInto, position + pos);
        decimalAt += 1;
      }
    }
  }
  





  public long transformNumber(long number)
  {
    return 0L;
  }
  




  public double transformNumber(double number)
  {
    return number - Math.floor(number);
  }
  






















  public Number doParse(String text, ParsePosition parsePosition, double baseValue, double upperBound, boolean lenientParse)
  {
    if (!byDigits) {
      return super.doParse(text, parsePosition, baseValue, 0.0D, lenientParse);
    }
    




    String workText = text;
    ParsePosition workPos = new ParsePosition(1);
    double result = 0.0D;
    






















    DigitList dl = new DigitList();
    while ((workText.length() > 0) && (workPos.getIndex() != 0)) {
      workPos.setIndex(0);
      int digit = ruleSet.parse(workText, workPos, 10.0D).intValue();
      if ((lenientParse) && (workPos.getIndex() == 0)) {
        Number n = rbnf.getDecimalFormat().parse(workText, workPos);
        if (n != null) {
          digit = n.intValue();
        }
      }
      
      if (workPos.getIndex() != 0) {
        dl.append(48 + digit);
        
        parsePosition.setIndex(parsePosition.getIndex() + workPos.getIndex());
        workText = workText.substring(workPos.getIndex());
        while ((workText.length() > 0) && (workText.charAt(0) == ' ')) {
          workText = workText.substring(1);
          parsePosition.setIndex(parsePosition.getIndex() + 1);
        }
      }
    }
    result = count == 0 ? 0.0D : dl.getDouble();
    
    result = composeRuleValue(result, baseValue);
    return new Double(result);
  }
  







  public double composeRuleValue(double newRuleValue, double oldRuleValue)
  {
    return newRuleValue + oldRuleValue;
  }
  


  public double calcUpperBound(double oldUpperBound)
  {
    return 0.0D;
  }
  







  char tokenChar()
  {
    return '>';
  }
}
