package com.ibm.icu.text;
















































































































































































































































































































































class MultiplierSubstitution
  extends NFSubstitution
{
  double divisor;
  














































































































































































































































































































































  MultiplierSubstitution(int pos, double divisor, NFRuleSet ruleSet, RuleBasedNumberFormat formatter, String description)
  {
    super(pos, ruleSet, formatter, description);
    



    this.divisor = divisor;
    
    if (divisor == 0.0D) {
      throw new IllegalStateException("Substitution with bad divisor (" + divisor + ") " + description.substring(0, pos) + " | " + description.substring(pos));
    }
  }
  





  public void setDivisor(int radix, int exponent)
  {
    divisor = Math.pow(radix, exponent);
    
    if (divisor == 0.0D) {
      throw new IllegalStateException("Substitution with divisor 0");
    }
  }
  








  public boolean equals(Object that)
  {
    if (super.equals(that)) {
      MultiplierSubstitution that2 = (MultiplierSubstitution)that;
      
      return divisor == divisor;
    }
    return false;
  }
  
  public int hashCode()
  {
    if (!$assertionsDisabled) throw new AssertionError("hashCode not designed");
    return 42;
  }
  








  public long transformNumber(long number)
  {
    return Math.floor(number / divisor);
  }
  








  public double transformNumber(double number)
  {
    if (ruleSet == null) {
      return number / divisor;
    }
    return Math.floor(number / divisor);
  }
  













  public double composeRuleValue(double newRuleValue, double oldRuleValue)
  {
    return newRuleValue * divisor;
  }
  




  public double calcUpperBound(double oldUpperBound)
  {
    return divisor;
  }
  







  char tokenChar()
  {
    return '<';
  }
}
